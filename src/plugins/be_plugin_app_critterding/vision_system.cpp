// void calcClipPlanes(glm::mat4& view, glm::mat4& projection)
// {
//     glm::mat4 viewProjectionMatrix = projection * view;
//     glm::vec4 row0 = glm::row(viewProjectionMatrix, 0);
//     glm::vec4 row1 = glm::row(viewProjectionMatrix, 1);
//     glm::vec4 row2 = glm::row(viewProjectionMatrix, 2);
//     glm::vec4 row3 = glm::row(viewProjectionMatrix, 3);
// 
//     g_leftClipPlane = row0 + row3;
//     g_rightClipPlane = row0 - row3;
//     g_bottomClipPlane = row1 + row3;
//     g_topClipPlane = row1 - row3;
//     g_nearClipPlane = row2 + row3;
//     g_farClipPlane = row2 - row3;
// }
// 
// bool isPointInsideViewFrustum(const glm::vec3& point)
// {
//     glm::vec4 p(point, 1.0);
// 
//     return glm::dot(p, g_leftClipPlane) >= 0 &&
//         glm::dot(p, g_rightClipPlane) <= 0 &&
//         glm::dot(p, g_bottomClipPlane) >= 0 &&
//         glm::dot(p, g_topClipPlane) <= 0 &&
//         glm::dot(p, g_nearClipPlane) >= 0 &&
//         glm::dot(p, g_farClipPlane) <= 0;
// }


#include "vision_system.h"
#include "plugins/be_plugin_opengl_modern/be_entity_graphics_model.h"
#include "plugins/be_plugin_bullet/be_entity_physics_entity.h"
#include "kernel/be_plugin_base_entity_types.h"
#include "critter_system.h"
#include <glm/gtc/type_ptr.hpp>
// #include <iostream>

	void CdVisionSystem::construct()
	{
		m_print = addChild("print", new BEntity_bool());
		// m_print->set( true );
		m_critter_sightrange = addChild("sight_range", new BEntity_float());
		m_critter_sightrange->set( 7.0f );

		m_critter_containers = addChild("critter_containers", new BEntity());
		
		m_drawEntities = 0;
		m_turn_180 = btTransform( btQuaternion( SIMD_PI, 0.0f, 0.0f ) );

		m_critter_retinasize = 6; // FIXME max 8?
		m_retinasperrow = 2048 / m_critter_retinasize;

		// vision retina allocation
		unsigned int items = 4 * 2048 * 2048;
		retina = (unsigned char*)malloc( items );
		memset( retina, 0, items );

		// generate namespace for the frame buffer, colorbuffer and depthbuffer
		glGenFramebuffersEXT(1, &fb);
		glGenTextures(1, &color_tex); 
		glGenRenderbuffersEXT(1, &depth_rb);

		//switch to our fbo so we can bind stuff to it
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fb);

		//create the colorbuffer texture and attach it to the frame buffer
		glBindTexture(GL_TEXTURE_2D, color_tex);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); 
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 2048, 2048, 0, GL_RGBA, GL_INT, NULL);
		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, color_tex, 0); 
		
		// create a render buffer as our depthbuffer and attach it
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depth_rb);
		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, 2048, 2048);
		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, depth_rb);

		// Go back to regular frame buffer rendering
		// glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
		
		m_graphics_system = dynamic_cast<BGraphicsModelSystem*>( parent()->getChild("GLWindow", 1)->getChild("GraphicsModelSystem", 1) );
		m_ProjectionViewMatrixID = glGetUniformLocation(  m_graphics_system->m_effect->m_program.get()->handle(), "ProjectionViewMatrix_Camera" );
		
		// shortcut to reset scale uniform, hackish
		m_e_scale_x = topParent()->getChild("bin", 1)->getChild("Critterding", 2)->getChild("GLWindow", 1)->getChild("GraphicsModelSystem", 1)->getChild("shaders", 1)->getChild("e_scale_x", 1);
	} 

	void CdVisionSystem::process()
	{
		if ( m_critter_sightrange->get_float() > 0.0f )
		{
			// std::cout << "------------- vision system START" << std::endl;
			if ( m_drawEntities == 0 )
			{
				m_drawEntities = topParent()->getChild("bin", 1)->getChild("Critterding", 2)->getChild("GLWindow", 1)->getChild("GraphicsModelSystem", 1);
			}

			glUseProgram( m_graphics_system->m_effect_critter->m_program.get()->handle() );

			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fb); 
			glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

		// FIXME HACK RESET ALL THE SHADERS?, idea is we don't have to brute force a change to the scale uniform down the line, do it here
			m_e_scale_x->set( 0.0f );

			bool empty(true);
			unsigned int critter_counter = 0;
			float buffer[16];
			for_all_children_of2( m_critter_containers )
			{
				auto container = (*child2)->get_reference();
				// for_all_children_of( m_unit_container )
				for_all_children_of( container )
				{
					calcFramePos( critter_counter );

					empty = false;
					CdCritter* critter = dynamic_cast<CdCritter*>( (*child) );

					if ( critter->m_physics_component == 0 )
					{
						critter->m_physics_component = critter->getChild("external_body", 1)->get_reference()->getChild("body_fixed1", 1)->getChild("bodyparts", 1)->getChild("external_bodypart_physics", 1)->get_reference();
					}

					auto bodypart_to_attach_cam = dynamic_cast<BPhysicsEntity*>( critter->m_physics_component )->getPhysicsComponent();
					
					if ( bodypart_to_attach_cam != 0 )
					{
						glViewport(framePosX, framePosY, m_critter_retinasize, m_critter_retinasize);
		// 
						auto ProjectionMatrixGLM = glm::perspective( SIMD_PI / 4, 1280.0f/800.0f, 0.1f, m_critter_sightrange->get_float() );
						
						// VIEW MATRIX GLM
							auto ViewMatrix = bodypart_to_attach_cam->getTransform() * m_turn_180;
							ViewMatrix.inverse().getOpenGLMatrix( buffer );
							glm::mat4 viewMatrix = glm::make_mat4( buffer );
							// glUniformMatrix4fv( m_ViewMatrixID, 1, GL_FALSE, glm::value_ptr(theMatrix) );


				// 		// PROJECTIONVIEW MATRIX GLM
							// glm::mat4 pvMatrix = glm::mat4(1.0f);
							// pvMatrix = m_ProjectionMatrixGLM * theMatrix;
							glm::mat4 pvMatrix = ProjectionMatrixGLM * viewMatrix;
							glUniformMatrix4fv( m_ProjectionViewMatrixID, 1, GL_FALSE, glm::value_ptr(pvMatrix) );					
						
						
						// glMatrixMode(GL_PROJECTION);
						// glLoadIdentity();
						// glFrustum( -0.05f, 0.05f, -0.05, 0.05, 0.1f, m_critter_sightrange->get_float());

						// // GET MATRIX
						// // bodypart_to_attach_cam->getTransform().getOpenGLMatrix( m_drawingMatrix );
						// m_pos_transform = bodypart_to_attach_cam->getTransform() * m_turn_180;
						// m_pos_transform.inverse().getOpenGLMatrix( m_drawingMatrix );
						// glMultMatrixf( m_drawingMatrix );

						// glMatrixMode(GL_MODELVIEW);
						// glLoadIdentity();
						
						// DRAW WORLD
							if ( m_drawEntities )
							{
								for_all_children_of3( m_drawEntities )
								{
									auto model = dynamic_cast<BGraphicsModel*>( (*child3) );
									if ( model )
									{
										// (*child2)->process();
										model->processWhenInSight( &bodypart_to_attach_cam->getTransform(), m_critter_sightrange->get_float() );
									}
								}
							}

						++critter_counter;
					}
				}
			}

			// Read pixels into retina
			if ( !empty )
			{
				unsigned int picwidth = m_retinasperrow * (m_critter_retinasize);
				unsigned int picheight = m_critter_retinasize;
				
				// unsigned int sum(0);
				unsigned int rows(0);
				for_all_children_of( m_critter_containers )
				{
					rows += (*child)->get_reference()->numChildren();
				}
				// unsigned int rows = m_unit_container->numChildren();
				
				while ( rows > m_retinasperrow )
				{
					picheight += m_critter_retinasize;
					rows -= m_retinasperrow;
				}
				glReadBuffer(GL_BACK);
				glPixelStorei( GL_UNPACK_ALIGNMENT, 1 );
				glReadPixels(0, 0, picwidth, picheight, GL_RGBA, GL_UNSIGNED_BYTE, retina);
				
				
				// FEED TO BRAIN
				critter_counter = 0;
				float value;
				float fvalue;
				for_all_children_of2( m_critter_containers )
				{
					auto container = (*child2)->get_reference();
					for_all_children_of( container )
					// for_all_children_of( m_unit_container )
					{
						CdCritter* critter = dynamic_cast<CdCritter*>( (*child) );

						// while vision_value_R not found
						if ( critter->m_brain_inputs == 0 )
						{
							critter->m_brain_inputs = (*child)->getChild("external_brain", 1)->get_reference()->getChild("inputs", 1);
						}
						
						// setup inputs and cycle through to the correct input
						const auto& brain_inputs_children_vector = critter->m_brain_inputs->children();
						const auto& brain_inputs_begin = brain_inputs_children_vector.begin();
						const auto& brain_inputs_end = brain_inputs_children_vector.end();
						auto brain_input = brain_inputs_begin;
						while ( brain_input != brain_inputs_end && (*brain_input)->name() != "vision_value_R" )
						{
							// std::cout << (*brain_input)->name() << std::endl;
							++brain_input;
						}

						// FEED
						calcFramePos( critter_counter );
						for ( unsigned int h=retinaRowStart; h < retinaRowStart+(m_critter_retinasize*retinaRowLength); h += retinaRowLength )
						{
							for ( unsigned int w=h+retinaColumnStart; w < h+retinaColumnStart+(m_critter_retinasize*4); ++w )
							{
								value = (int)retina[w];
								if ( value > 0 )
								{
									fvalue = (float)value / 255;
									// std::cout << "setting brain_input " << (*brain_input)->name() << " to " << ((float)(int)retina[w]) / 255 << std::endl;

									// if it's the same, force update to outputs
									if ( !(*brain_input)->set( fvalue ) )
									{
										(*brain_input)->onUpdate();
									}
								}
								++brain_input;
							}
						}

						++critter_counter;
					}
				}
				
				
				// PRINT
				if ( m_print->get_bool() )
				{
					critter_counter = 0;
					for_all_children_of2( m_critter_containers )
					{
						auto container = (*child2)->get_reference();
						for_all_children_of( container )
						// for_all_children_of( m_unit_container )
						{
							calcFramePos(critter_counter);
							std::cout << "critter " << critter_counter << ":" << " x:" << retinaColumnStart << " y:" << retinaRowStart << " retinaRowLength: " << retinaRowLength << std::endl;

							for ( unsigned int h=retinaRowStart; h < retinaRowStart+(m_critter_retinasize*retinaRowLength); h += retinaRowLength )
							{
								for ( unsigned int w=h+retinaColumnStart; w < h+retinaColumnStart+(m_critter_retinasize*4); w+=4 )
								{
									if ( (int)retina[w+0] > 80 ) std::cout << "\033[1;31mR\033[0m";
									else std::cout << ".";
									if ( (int)retina[w+1] > 80 ) std::cout << "\033[1;32mG\033[0m";
									else std::cout << ".";
									if ( (int)retina[w+2] > 80 ) std::cout << "\033[1;34mB\033[0m";
									else std::cout << ".";
									if ( (int)retina[w+3] > 80 ) std::cout << "\033[1;35mA\033[0m";
									else std::cout << ".";
								}
								std::cout << std::endl;
							}
							std::cout << std::endl;

							critter_counter++;
						}
					}
				}
			}
			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0); 
			// std::cout << "------------- vision system STOP" << std::endl;
		}
	}

	bool CdVisionSystem::set( const Bstring& id, BEntity* value )
	{
		if ( id == "register_container" )
		{
			// std::cout << "CdVisionSystem::registered container " << value->name() << std::endl;
			m_critter_containers->addChild( "container", new BEntity_reference() )->set( value ) ;

			return true;
		}

		std::cout << "CdVisionSystem::warning: unknown command '" << id << "'" << std::endl;
		return false;
	}	
	
	void CdVisionSystem::calcFramePos(unsigned int pos)
	{
		// unsigned int m_retinasperrow = 50;
		visionPosition = pos;

		// Calc 2D cartesian vectors X & Y for frame positioning of retina
		framePosY = 0;
		while ( pos >= m_retinasperrow )
		{
			pos -= m_retinasperrow;
			framePosY += m_critter_retinasize;
		}
		framePosX = (pos * m_critter_retinasize);

		// Calculate where in the Great Retina this critter shold start (column & row)
		unsigned int target = visionPosition;
		retinaRowStart = 0;

		// determine on which row of the retina to start for this critter
		retinaRowLength = m_retinasperrow * m_critter_retinasize * 4;

		// determine on which column to start
		while ( target >= m_retinasperrow )
		{
			retinaRowStart += m_critter_retinasize * retinaRowLength;
			target -= m_retinasperrow;
		}
		retinaColumnStart = target * m_critter_retinasize * 4;
	}

	CdVisionSystem::~CdVisionSystem()
	{
		free(retina);
	}
	
